# dspytbus.py - the Desperately Silly PYthon Threaded message BUS
# See files README and COPYING for copyright and licensing details.

"""
the Desperately Silly PYthon Threaded message BUS

First off, this is probably an even *worse* idea than the original
dspytbus. Heck, it's not even *threaded* anymore, making it fully
oxymoronic instead! But what is it?

I got frustrated with the complexity of the otherwise excellent
circuits framework by my pal prologic. I love his stuff, but it's
just so full of implicit assumptions that it's hard to get one's
head around starting out. I appreciate how well it all works in
his hands, but it sure doesn't in mine, at least not yet.

All my frustration lead me to think about alternative ways to
structure a component framework, and one way I couldn't get out
of my head was based on lots of threads ... Wait, that's the other
version, not this one.

In *this* dspytbus, every component is a process. Components get
attached to busses which are also processes. Busses can be attached
to other busses, so they are really also components at the same
time. The components communicate through messages, and when you
attach one to a bus, you can define what types of messages that
component is interested in.

So aside from processes instead of threads, what's "better" about
this version? First, since we use sockets for communication, you
can use it for *distributed* component systems. Second, components
can now join and leave a bus at any time, so you can reconfigure
your component system dynamically (but killing a bus will kill the
attached components). That's about it.

Just like the previous iteration of dspytbus, this is just a quick
prototype, not a framework ready for production use. Feel free to
hack on it if you think it has merit, that's why it's on github.com
after all.
"""

from abc import ABCMeta, abstractmethod
import logging
from multiprocessing import Process
from multiprocessing.connection import Client, Listener
import select

LOGGER = logging.getLogger('dspytbus')

class Message(object):
    """
    Messages shuffle data between components through busses.

    You can do whatever you want with subclasses of Message.
    Actually, you don't have to use the class at all: if you
    can pickle it, you can send it.
    """
    pass

class Dspyt(Message):
    """
    Messages generated by busses.

    Provide metainformation about what is going on in the system.
    """
    def __init__(self, bus):
        self.bus = bus

class ComponentJoined(Dspyt):
    """
    Component has joined bus.
    """
    def __init__(self, bus, component):
        super(ComponentJoined, self).__init__(bus)
        self.component = component
    def __repr__(self):
        return "Component %s joined bus %s." % (self.component, self.bus)

class ComponentLeft(Dspyt):
    """
    Component has left bus.
    """
    def __init__(self, bus, component):
        super(ComponentLeft, self).__init__(bus)
        self.component = component
    def __repr__(self):
        return "Component %s left bus %s." % (self.component, self.bus)

class LostBus(Dspyt):
    """
    Lost connection to outer bus.
    """
    def __init__(self, bus, other):
        super(LostBus, self).__init__(bus)
        self.other = other
    def __repr__(self):
        return "Bus %s lost connection to outer bus %s." % (self.bus,
                                                            self.other)

class FoundGPS(Dspyt):
    """
    Outer bus is back, woohoo!
    """
    def __init__(self, bus, other):
        super(FoundGPS, self).__init__(bus)
        self.other = other
    def __repr__(self):
        return "Bus %s reacquired connection to outer bus %s." % (self.bus,
                                                                  self.other)

class Shutdown(Dspyt):
    """
    Bus is going down!
    """
    def __init__(self, bus):
        super(Shutdown, self).__init__(bus)
    def __repr__(self):
        return "SOS. Bus %s is going down. RIP." % (self.bus)

DEFAULT_ADDRESS = ('localhost', 49152)

def interests(*args):
    """
    Declare (message) types a (handler) callable is interested in.

    Raise exception if decoree is not a callable, interest is not a
    type, or same type is covered multiple times (object, for example,
    covers everything so specifying a type besides object will fail).
    """
    def decorate(f):
        def enforce_no_cover(types):
            # expensive! but probably worth it in the long run
            for ty in types:
                rest = types[:]
                rest.remove(ty)
                # tupled issubclass()? better warning this way
                for ry in rest:
                    if issubclass(ty, ry):
                        raise Exception(
                            "Type %s already covered by type %s." % (ty, ry)
                        )
        if not callable(f):
            raise Exception("Only callables can have interests.")
        types = []
        for ar in args:
            if not isinstance(ar, type):
                raise Exception("You can only be interested in types!")
            types.append(ar)
        enforce_no_cover(types)
        setattr(f, "__interests__", types)
        return f
    return decorate

class Base(Process):
    """
    Abstract base class for components and busses.
    """
    __metaclass__ = ABCMeta

class Component(Base):
    """
    Components send and receive messages.

    Remember to call __init__() from your constructor! Subclass
    this and implement handle_message() to actually do stuff.
    Don't override anything but __init__() and handle_message()!
    """
    def __init__(self, bus=DEFAULT_ADDRESS, authkey=None, interests=None):
        """
        Initialize a new component.

        Connect to bus (host, port) with given authorization key and
        interests; interests can be a class, type, or tuple of these;
        if interests is None, the __interests__ attribute is used; if
        __interests__ does not exist, object is used.

        The constructor should always be called with keyword arguments.
        """
        super(Component, self).__init__()
        self._bus = Client(address=bus, authkey=authkey)
        assert self._bus is not None
        if interests is None:
            interests = getattr(self, "__interests__", object)
        self._bus.send(interests)
        self._bus_address = bus

    def send_message(self, message):
        """
        Send a message out of this component.

        Don't call this from the outside!
        """
        self._bus.send(message)

    @abstractmethod
    def handle_message(self, message):
        """
        Handle a message.

        You must override this!
        """
        assert False, "You must override this!"

    def run(self):
        """
        The component receives and dispatches messages here.

        Don't override this!
        """
        while True:
            msg = self._bus.recv()
            self.handle_message(msg)

class Bus(Component):
    """
    Busses broadcast/route messages between components.

    Don't subclass this. Just use it.
    """
    def __init__(self, address=DEFAULT_ADDRESS, authkey=None, backlog=4,
                 bus=None, buskey=None, businterests=object):
        """
        Initialize a new bus.

        This takes a large number of arguments because a bus can be a
        component for an outer bus. The first three arguments concern
        the bus to be created: the (host, port) address it listens on,
        the authorization key components need to use, and the backlog
        of connections before the bus turns down further connections.

        The last three concern the outer bus: the (host, port) where
        the outer bus can be reached, the authorization key for the
        outer bus, and the interests this bus has in terms of messages
        passing through the outer bus.

        The constructor should always be called with keyword arguments.
        """
        # if there is no outer bus, we need to skip the constructor of
        # the component class, otherwise we'd try to connect to the
        # default bus; Python *is* a messed up language after all as
        # it allows this to be done :-D
        LOGGER.debug("__init__")
        if bus is not None:
            super(Bus, self).__init__(bus=bus, authkey=buskey,
                                      interests=businterests)
        else:
            super(Component, self).__init__()
            self._bus = None
        self._listener = Listener(address=address, backlog=backlog,
                                  authkey=authkey)
        self._listener_socket = self._listener._listener._socket
        self._components = []
        self._interests = {}
        self._addresses = {}

    def __select(self):
        """
        Select sockets that are ready.

        Uses select.select() to wait for new connections, messages on
        the outer bus, and messages from components on this bus.
        """
        LOGGER.debug("__select")
        readers = []
        if self._bus is not None:
            readers.append(self._bus)
        readers.append(self._listener_socket)
        for co in self._components:
            readers.append(co)
        exceptions = readers[:]
        return select.select(readers, [], exceptions)

    def handle_message(self, message):
        """
        Unused.
        """
        pass

    def __accept(self):
        """
        Accept connection from component.

        The component must send its interests immediately after it
        connects, otherwise the connection will be aborted after a
        brief timeout. Once the component is fully accepted, broadcast
        ComponentJoined message.
        """
        LOGGER.debug("__accept")
        component = self._listener.accept()
        if component.poll(0.1):
            interests = component.recv() # TODO: try/except?
            self._components.append(component)
            self._interests[component] = interests
            self._addresses[component] = self._listener.last_accepted
            msg = ComponentJoined(self._listener.address,
                                  self._listener.last_accepted)
            self.__broadcast(msg, self)
        else:
            LOGGER.debug("__accept: component %s:%s failed to send interests" %
                         self._listener.last_accepted)
            component.close()

    def __broadcast(self, message, origin):
        """
        Broadcast a message.

        Never sends a message back to its origin. If there is an
        outer bus, send the message. If there are components who
        are interested, send the message.
        """
        LOGGER.debug("__broadcast")
        if self._bus is not None and self._bus is not origin:
            self._bus.send(message) # TODO: try/except?
        for co in self._components:
            if co is not origin and isinstance(message, self._interests[co]):
                try:
                    co.send(message)
                except IOError as e:
                    self.__lost(co)

    def __lost(self, connection):
        """
        Lost a connection.

        If connection to outer bus was lost, broadcast LostBus
        message. If connection to component was lost, broadcast
        ComponentLeft message. Either way, close connection and
        clean up.
        """
        LOGGER.debug("__lost")
        if self._bus is not None and connection is self._bus:
            self._bus.close()
            self._bus = None
            self.__broadcast(LostBus(), self)
        elif connection in self._components:
            connection.close()
            self._components.remove(connection)
            address = self._addresses[connection]
            del self._addresses[connection]
            del self._interests[connection]
            msg = ComponentLeft(self._listener.address, address)
            self.__broadcast(msg, self)
        else:
            assert False, "what just happened?"

    def run(self):
        """
        The bus receives and dispatches messages here.

        Don't override this!
        """
        LOGGER.debug("run")
        while True:
            readers, writers, exceptions = self.__select()
            assert len(writers) == len(exceptions) == 0
            for r in readers:
                if r is self._listener_socket:
                    self.__accept()
                else:
                    try:
                        msg = r.recv()
                        self.__broadcast(msg, r)
                    except (EOFError, IOError) as e:
                        self.__lost(r)
